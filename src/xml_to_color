# Copyright © 2020 Miguel González Cuadrado <mgcuadrado@gmail.com>

# This file is part of Testudo.

#     Testudo is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.

#     Testudo is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.

#     You should have received a copy of the GNU General Public License
#     along with Testudo.  If not, see <http://www.gnu.org/licenses/>.

#!/bin/bash

line_length=78
margin=6

while getopts "blsw:" option; do
    case $option in
        b) black=true ;;
        l) latex=true ;;
        s) summary=true ;;
        w) line_length=${OPTARG} ;;
        *) echo "invalid option"; exit 1 ;;
    esac
done

if [ -n "$black" ]; then
    normal=""
    bold=""
    lines=""
    failure=""
    successtag=""
    failuretag=""
    error=""
    ident=""
elif [ -n "$latex" ]; then
    normal="@color{black}@mdseries{}"
    bold="@bfseries{}"
    lines="@color{orange}"
    failure="@color{red}"
    successtag="@color{green}"
    # "failure" and "error" below is a horrible hack to have red bg
    failuretag="@color{red}@makebox[0pt][l]{@sethlcolor{yellow}@hl{     }}"
    error="@color{yellow}@makebox[0pt][l]{@sethlcolor{red}@hl{     }}"
    ident="@color{blue}"
else
    normal=$(echo  -e "\033[0;39m")
    bold=$(echo    -e "\033[1;39m")
    lines=$(echo   -e "\033[0;33m")
    failure=$(echo -e "\033[1;31m")
    successtag=$(echo -e "\033[0;32m")
    failuretag=$(echo -e "\033[1;43;31m")
    error=$(echo -e "\033[1;41;33m")
    ident=$(echo   -e "\033[1;34m")
fi

if [ -z $summary ]; then
    xml_format=testarudo.xslt
else
    xml_format=testarudo_summary.xslt
fi

if [ -n "$latex" ]; then
    replace_specials='s/@/@atsign@@/g
                      s/{/@openbrace@@/g
                      s/}/@closebrace@@/g
                      s/\(@atsign\|@openbrace\|@closebrace\)@@/\1{}/g'
    global_cleaning='${/^$/d}' # remove last line if empty
else
    replace_specials=''
    global_cleaning=''
fi

line_length_times_first=$(for n in $(seq $line_length); do echo -n '\1'; done)
cartouche_length_periods=$(
    for n in $(seq $((line_length-margin+2))); do echo -n .; done)
text_style_marker_names="ident|bold|lines|failure|successtag|failuretag|error"

if [ -n "$latex" ]; then
    echo "% use packages fancyvrb and soul"
    echo "% make \\sethlcolor{red}"
    echo "% define \\openbrace{}, \\closebrace{}, and \\atsign{}"
    echo '\begin{Verbatim}[numbers=left, %'
    echo '  frame=single, rulecolor=\color{black!25}, commandchars=@\{\}]'
fi

# after the "xsltproc" phase, there are some typesetting marks that we have to
# implement here:
#   ||~bold~|| make font bold
#   ||~normal~|| make font normal
#   ||~lines~|| set lines colour (orange)
#   ||~failure~|| set failure colour (red)
#   ||~successtag~|| set success tag colour (green)
#   ||~failuretag~|| set failure tag colour (red on yellow background)
#   ||~errortag~|| set error tag colour (yellow on red background)
#   ||~ident~|| set Testudo identifier colour (blue)
#   ||~indent_as_b~|| beginning of test name for indented line; each non-last
#   ||~indent_as_e~|| ... test name elements is removed and adds to the indent
#   ||~cartouche~|| typeset the whole line in an orange cartouche
#   ||~multiline_begin~|| beginning of multiline text
#   ||~multiline_end~|| end of multiline text
#   ||~right~||c typeset the rest of the line flish right, filling with 'c'
#   ||~full~||c typeset a whole line of 'c'

# TODO
#   make ||~...tag~|| stand for the whole tag including the letters, not just
#     for the colours

# algorithm:
#   1. process ||~indent_as_b~|| and ||~indent_as_e~||
#   2. process ||~inc_indent~|| and ||~dec_indent~||
#   3. break lines up until ||~right~||, disregarding other ||~...~|| markers;
#      the line breaks must consist of "||~break~||\n" (for cartouches)
#   4. process cartouches (using "||~break~||" for multiline detection
#   5. process ||~right~|| and ||~full~||
#   6. process ||~multiline_begin~|| and ||~multiline_end~||
#   7. process the rest of the markers (all colours and remove ||~break~||)

xsltproc "$(dirname "$0")"/$xml_format - | sed ' # indents
    /||~indent_as_b~||.*||~indent_as_e~||/{
        h # keep the original line in hold space
        s/.*||~indent_as_b~||\(.*\)||~indent_as_e~||.*/\1/ # keep only the name
        s/[^.]//g # remove non-dots
        s/\./    /g # replace each dot with an indentation
        G # append hold space
        s/\n// # remove newline from append
        # replace hierarchy in test name with "-"
        s/\(||~indent_as_b~||\).*\(\..*||~indent_as_e~||\)/\1-\2/
        s/||~indent_as_[be]~||//g # remove indentation marks
    }' | sed ' # ||~inc_indent~|| and ||~dec_indent~||
    /||~inc_indent~||/ {x;s/$/  /;x;d}
    /||~dec_indent~||/ {x;s/  $//;x;d}
    G
    s/\(.*\)\n\(.*\)/\2\1/
' | awk '
    { # break lines
        # margin a the rigth, so the OK/FAIL/ERR- tags stand out
        margin='$margin'
        break_mark="||~break~||\\\n"
        initial_indent=substr($0, 0, match($0, /[^ ]/)-1)
        indent="    " initial_indent # indent for broken line continuations
        line=$0
        # chars left to fill the available space (-1 for the continuation
        # backslash)
        cleft='$line_length'-margin-1
        i=1 # line iterator
        style=""
        while (i<=length(line)) {
            break_at=i # last position we could break at
            if (match(substr(line, i), /^\|\|~right~\|\|/)) { # flush tag right
                # now, we can recover the available space for the margin and
                # the continuation backslash
                cleft+=margin+1
                while (i<=length(line)) {
                    if (match(substr(line, i), /^\|\|~[a-z_]*~\|\|/))
                        i+=RLENGTH # skip markers
                    else { # if no marker...
                        --cleft # ... one char fewer...
                        ++i # ... and increment iterator
                    }
                }
            }
            else if (match(substr(line, i), /^\|\|~[a-z_]*~\|\|/)) {
                i=i+RLENGTH # skip markers
                marker=substr(line, i-RLENGTH, RLENGTH)
                if (marker=="||~normal~||")
                    style=""
                else if (match(marker,
                               /\|\|~('$text_style_marker_names')~\|\|/))
                    style=marker
            }
            else { # if no marker...
                --cleft # ... one char fewer
                ++i # ... and increment iterator
            }
            if (cleft<0) { # at least one char past the available space
                # break at last breakable position, and insert break and indent
                line=(substr(line, 1, break_at-1) \
                      break_mark indent style substr(line, break_at))
                # adjust the iterator by the length of the inserted text
                i+=length(break_mark indent style)
                # adjust "cleft", but indent shortens the available space (and
                # again, -1 for the continuation backslash)
                cleft+='$line_length'-margin-1-length(indent)
            }
        }
        print line
    }
' | sed ' # cartouches
    /||~cartouche~||/{
        s/// # remove the marker
        s/.*/ & / # surround with spaces
        h # keep the original line in hold space
        s/||~[a-z_]*~||//g # remove markers
        s/./_/g # upper line
        s/^/ / # upper left corner
        s/^/||~lines~||/ # colour the upper line
        s/$/||~normal~||/ # colour the upper line
        p # print upper line
        x # swap upper line with original line
        : flank
        s/^/||~lines~|||||~normal~||/ # left vertical line
        s/$/||~lines~|||||~normal~||/ # right vertical line
        p # print text (original line flanked with vertical lines)
        /||~break~||/{ # if this line was broken
            s/.//g # clean the pattern space
            N # read next line
            s/\n/ / # remove \n from appending and add the left space
            H # append the line to the hold space
            # now, the hold space contains the bottom line and the current line
            s/||~[a-z_]*~||//g # remove markers
            s/././g # replace all characters with a dot
            s/$/ /
            s/\( \)$/'$line_length_times_first'/ # add enough spaces at the end
            s/^\('$cartouche_length_periods'\).*$/\1/ # and trim for length
            s/^\.*// # remove the dots so we are left with the filler spaces
            G # append the hold space, witn a \n separator
            s/^\(.*\)\n\(.*\)\n\(.*\)$/\3\1/ # reorder: current line, fillers
            { # clean the hold space so that it contains the bottom line only
                x
                s/\n.*//
                x
            }
            b flank # and go back to flanking with vertical lines
        }
        x # recover upper line; we will transform it into the lower line
        s/||~[a-z_]*~||//g # remove markers
        s/_/-/g # raise line
        s/^./||~lines~||`/ # lower left corner
        s/$/'"'"'||~normal~||/ # lower right corner
    }
' | sed ' # ||~right~|| and ||~full~||
    /||~right~||/{
        h # keep the original line in hold space
        # remove alignment marker and its next char, and add a newline
        # followed by line_length times the char that followed the marker:
        s/||~right~||\(.\)\(.*\)/\2\n'$line_length_times_first'/
        s/||~[a-z_]*~||//g # remove markers
        s/\(.\{'$line_length'\}\).*/\1/ # keep only first line_length chars...
        /\n/!s/.//g # if we ate the newline, the original line was too long
        s/.*\n// # ... but remove the original contents
        H # ... and append the rest to the original line
        x # get the augmented line: <original line>\n<additional space>
        s/||~right~||\(.*\)\n\(.*\)/\2\1/ # insert additional space at marker
    }
    s/||~full~||\(.\)/'$line_length_times_first'/
' | sed ' # multiline
    /||~multiline_begin~||||~multiline_end~||/{ # empty multiline
        s/// # just remove
    }
    /||~multiline_begin~||.\+||~multiline_end~||/{ # one-line multiline
        s/||~multiline_begin~||/\n  ||~ident~|||||~normal~||/
        s/||~multiline_end~||//
    }
    /||~multiline_begin~||/,/||~multiline_end~||/ { # multiline multiline
        /||~multiline_begin~||/{ # for the first line, just break and add tab
            # no nl if there is nothing before the marker:
            s/^||~multiline_begin~||/  ||~ident~|||||~normal~|| /
             # otherwise, nl
            s/||~multiline_begin~||/\n  ||~ident~|||||~normal~|| /
            p
            d
        }
        /^||~multiline_end~||/d # remove a last empty line
        s/||~multiline_end~||// # remove end marker
        # for all non-first lines, break and add tab
        s/^/  ||~ident~|||||~normal~|| /
    }
' | sed ' # colours and specials
    '"$replace_specials"'
    s/||~normal~||/'"$normal"'/g
    s/||~bold~||/'"$bold"'/g
    s/||~lines~||/'"$lines"'/g
    s/||~failure~||/'"$failure"'/g
    s/||~successtag~||/'"$successtag"'/g
    s/||~failuretag~||/'"$failuretag"'/g
    s/||~errortag~||/'"$error"'/g
    s/||~ident~||/'"$ident"'/g
    s/||~break~||/'"$normal"'/g # so that the backslash has normal format
    s/||~tilde~||//g # 
' | sed "$global_cleaning"

if [ -n "$latex" ]; then
    echo '\end{Verbatim}'
fi
