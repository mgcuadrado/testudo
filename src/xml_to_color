# Copyright © 2020 Miguel González Cuadrado <mgcuadrado@gmail.com>

# This file is part of Testudo.

#     Testudo is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.

#     Testudo is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.

#     You should have received a copy of the GNU General Public License
#     along with Testudo.  If not, see <http://www.gnu.org/licenses/>.

#!/bin/bash

line_length=78
margin=6

while getopts "rblsw:" option; do
    case $option in
        r) raw=true ;;
        b) black=true ;;
        l) latex=true ;;
        s) summary=true ;;
        w) line_length=${OPTARG} ;;
        *) echo "invalid option"; exit 1 ;;
    esac
done

if [ -n "$black" ]; then
    normal=""
    bold=""
    lines=""
    failure=""
    successtag=""
    failuretag=""
    error=""
    ident=""
elif [ -n "$latex" ]; then
    normal="@color{black}@mdseries{}"
    bold="@bfseries{}"
    lines="@color{orange}"
    failure="@color{red}"
    successtag="@color{green}"
    # "failure" and "error" below is a horrible hack to have red bg
    failuretag="@color{red}@makebox[0pt][l]{@sethlcolor{yellow}@hl{     }}"
    error="@color{yellow}@makebox[0pt][l]{@sethlcolor{red}@hl{     }}"
    ident="@color{blue}"
else
    normal=$(echo  -e "\033[0;39m")
    bold=$(echo    -e "\033[1;39m")
    lines=$(echo   -e "\033[0;33m")
    failure=$(echo -e "\033[1;31m")
    successtag=$(echo -e "\033[0;32m")
    failuretag=$(echo -e "\033[1;43;31m")
    error=$(echo -e "\033[1;41;33m")
    ident=$(echo   -e "\033[1;34m")
fi

if [ -z $summary ]; then
    xml_format=testarudo.xslt
else
    xml_format=testarudo_summary.xslt
fi

if [ -n "$latex" ]; then
    replace_specials='s/@/@atsign@@/g
                      s/{/@openbrace@@/g
                      s/}/@closebrace@@/g
                      s/\(@atsign\|@openbrace\|@closebrace\)@@/\1{}/g'
    global_cleaning='${/^$/d}' # remove last line if empty
else
    replace_specials=''
    global_cleaning=''
fi

line_length_times_first=$(for n in $(seq $line_length); do echo -n '\1'; done)
cartouche_length_periods=$(
    for n in $(seq $((line_length-margin+2))); do echo -n .; done)
text_style_marker_names="ident|bold|lines|failure|successtag|failuretag|error"

if [ -n "$latex" ]; then
    echo "% use packages fancyvrb and soul"
    echo "% make \\sethlcolor{red}"
    echo "% define \\openbrace{}, \\closebrace{}, and \\atsign{}"
    echo '\begin{Verbatim}[numbers=left, %'
    echo '  frame=single, rulecolor=\color{black!25}, commandchars=@\{\}]'
fi

# after the "xsltproc" phase, there are some typesetting marks that we have to
# implement here:
#   ||~bold~|| make font bold
#   ||~normal~|| make font normal
#   ||~lines~|| set lines colour (orange)
#   ||~failure~|| set failure colour (red)
#   ||~successtag~|| set success tag colour (green)
#   ||~failuretag~|| set failure tag colour (red on yellow background)
#   ||~errortag~|| set error tag colour (yellow on red background)
#   ||~ident~|| set Testudo identifier colour (blue)
#   ||~indent_as_b~|| beginning of test name for indented line; each non-last
#   ||~indent_as_e~|| ... test name elements is removed and adds to the indent
#   ||~cartouche~||l\nt typeset "l" and "t" in an orange cartouche
#   ||~multiline_begin~|| beginning of multiline text
#   ||~multiline_end~|| end of multiline text
#   ||~right~||c typeset the rest of the line flush right, filling with 'c'
#   ||~full~||c typeset a whole line of 'c'

# TODO
#   make ||~...tag~|| stand for the whole tag including the letters, not just
#     for the colours

# algorithm:
#   1. process ||~indent_as_b~|| and ||~indent_as_e~||
#   2. process ||~inc_indent~|| and ||~dec_indent~||
#   3. break lines up until ||~right~||, disregarding other ||~...~|| markers;
#      the line breaks must consist of "||~break~||\n" (for cartouches)
#   4. process cartouches (using "||~break~||" for multiline detection
#   5. process ||~right~|| and ||~full~||
#   6. process ||~multiline_begin~|| and ||~multiline_end~||
#   7. process the rest of the markers (all colours and remove ||~break~||)

if [ -n "$raw" ]; then
    xsltproc "$(dirname "$0")"/$xml_format -
    exit
fi

xsltproc "$(dirname "$0")"/$xml_format - | sed ' # indents
    /||~indent_as_b~||.*||~indent_as_e~||/{
        h # keep the original line in hold space
        s/.*||~indent_as_b~||\(.*\)||~indent_as_e~||.*/\1/ # keep only the name
        s/[^.]//g # remove non-dots
        s/\./    /g # replace each dot with an indentation
        G # append hold space
        s/\n// # remove newline from append
        # replace hierarchy in test name with "-"
        s/\(||~indent_as_b~||\).*\(\..*||~indent_as_e~||\)/\1-\2/
        s/||~indent_as_[be]~||//g # remove indentation marks
    }' | sed ' # ||~inc_indent~|| and ||~dec_indent~||
    /||~inc_indent~||/ {x;s/$/||~space_b~||  ||~space_e~||/;x;d}
    /||~dec_indent~||/ {x;s/||~space_b~||  ||~space_e~||$//;x;d}
    G
    s/\(.*\)\n\(.*\)/\2\1/
' | awk '
    { # break lines
        # margin a the rigth, so the OK/FAIL/ERR- tags stand out
        margin='$margin'
        break_mark="||~break~||\\\n"
        initial_indent=substr($0, 0, match($0, /[^ ]/)-1)
        match($0, /^.*\|\|~space_e~\|\|/)
        initial_indent=substr($0, 0, RLENGTH)
        gsub(/\|\|~space_[be]~\|\|/, "", initial_indent)
        indent="    " initial_indent # indent for broken line continuations
        line=$0
        # chars left to fill the available space (-1 for the continuation
        # backslash)
        cleft='$line_length'-margin-1
        i=1 # line iterator
        style=""
        while (i<=length(line)) {
            break_at=i # last position we could break at
            if (match(substr(line, i), /^\|\|~right~\|\|/)) { # flush tag right
                # now, we can recover the available space for the margin and
                # the continuation backslash
                cleft+=margin+1
                while (i<=length(line)) {
                    if (match(substr(line, i), /^\|\|~[a-z_]*~\|\|/))
                        i+=RLENGTH # skip markers
                    else { # if no marker...
                        --cleft # ... one char fewer...
                        ++i # ... and increment iterator
                    }
                }
            }
            else if (match(substr(line, i), /^\|\|~[a-z_]*~\|\|/)) {
                i=i+RLENGTH # skip markers
                marker=substr(line, i-RLENGTH, RLENGTH)
                if (marker=="||~normal~||")
                    style=""
                else if (match(marker,
                               /\|\|~('$text_style_marker_names')~\|\|/))
                    style=marker
            }
            else { # if no marker...
                --cleft # ... one char fewer
                ++i # ... and increment iterator
            }
            if (cleft<0) { # at least one char past the available space
                # break at last breakable position, and insert break and indent
                line=(substr(line, 1, break_at-1) \
                      break_mark indent style substr(line, break_at))
                # adjust the iterator by the length of the inserted text
                i+=length(break_mark indent style)
                # adjust "cleft", but indent shortens the available space (and
                # again, -1 for the continuation backslash)
                cleft+='$line_length'-margin-1-length(indent)
            }
        }
        print line
    }
' | awk '
    /^\|\|~cartouche~\|\|/ {
         gsub(/^\|\|~cartouche~\|\|/, "") # remove cartouche mark
         location=$0 # the rest of the line is the location
         text=location # temporary to measure location length
         gsub(/\|\|~[a-z_]*~\|\|/, "", text) # remove all marks
         location_width=length(text) # location length
         getline # the next line is the first (or only) line for the text title
         title=$0
         text=title # temporary to measure the length of this title line
         gsub(/\|\|~[a-z_]*~\|\|/, "", text)
         title_width=length(text) # title line length
         # "width" will be the inner width of the cartouche; if the title spans
         # several lines, the first one is already the maximum width
         width=location_width
         if (title_width>width)
             width=title_width # "width" is "max(location_width, title_width)"
         # print cartouche top border:
         line="||~lines~|| _"
         for (i=0; i<width; i++)
             line=line "_"
         line=line "_||~normal~||"
         print line
         # if non-empty, add a line for the location info:
         if (location!="") {
             line="||~lines~||| " location
             for (i=0; i<width-location_width; i++)
                 line=line " "
             line=line " |||~normal~||"
             print line
         }
         while (1) {
             # write the title line
             line="||~lines~|||||~normal~|| " title
             for (i=0; i<width-title_width; i++)
                 line=line " "
             line=line " ||~lines~|||||~normal~||"
             print line
             # if it is not the last line of the title, iterate:
             if (match(title, /\|\|~break~\|\|/)) {
                 getline
                 title=$0
                 text=title
                 gsub(/\|\|~[a-z_]*~\|\|/, "", text)
                 title_width=length(text)
             }
             else
                 break
         }
         # print cartouche bottom border:
         line="||~lines~||`-"
         for (i=0; i<width; i++)
             line=line "-"
         line=line "-'"'"'||~normal~||"
         print line

         next # avoid the general "print" below
    }
    {
        print
    }
' | sed ' # ||~right~|| and ||~full~||
    /||~right~||/{
        h # keep the original line in hold space
        # remove alignment marker and its next char, and add a newline
        # followed by line_length times the char that followed the marker:
        s/||~right~||\(.\)\(.*\)/\2\n'$line_length_times_first'/
        s/||~[a-z_]*~||//g # remove markers
        s/\(.\{'$line_length'\}\).*/\1/ # keep only first line_length chars...
        /\n/!s/.//g # if we ate the newline, the original line was too long
        s/.*\n// # ... but remove the original contents
        H # ... and append the rest to the original line
        x # get the augmented line: <original line>\n<additional space>
        s/||~right~||\(.*\)\n\(.*\)/\2\1/ # insert additional space at marker
    }
    s/||~full~||\(.\)/'$line_length_times_first'/
' | sed ' # multiline
    /||~multiline_begin~||||~multiline_end~||/{ # empty multiline
        s/// # just remove
    }
    /||~multiline_begin~||.\+||~multiline_end~||/{ # one-line multiline
        s/||~multiline_begin~||/\n  ||~ident~|||||~normal~||/
        s/||~multiline_end~||//
    }
    /||~multiline_begin~||/,/||~multiline_end~||/ { # multiline multiline
        /||~multiline_begin~||/{ # for the first line, just break and add tab
            # no nl if there is nothing before the marker:
            s/^||~multiline_begin~||/  ||~ident~|||||~normal~|| /
             # otherwise, nl
            s/||~multiline_begin~||/\n  ||~ident~|||||~normal~|| /
            p
            d
        }
        /^||~multiline_end~||/d # remove a last empty line
        s/||~multiline_end~||// # remove end marker
        # for all non-first lines, break and add tab
        s/^/  ||~ident~|||||~normal~|| /
    }
' | sed ' # colours and specials
    '"$replace_specials"'
    s/||~normal~||/'"$normal"'/g
    s/||~bold~||/'"$bold"'/g
    s/||~lines~||/'"$lines"'/g
    s/||~failure~||/'"$failure"'/g
    s/||~successtag~||/'"$successtag"'/g
    s/||~failuretag~||/'"$failuretag"'/g
    s/||~errortag~||/'"$error"'/g
    s/||~ident~||/'"$ident"'/g
    s/||~break~||/'"$normal"'/g # so that the backslash has normal format
    s/||~space_[be]~||//g
    s/||~tilde~||//g
' | sed "$global_cleaning"

if [ -n "$latex" ]; then
    echo '\end{Verbatim}'
fi
