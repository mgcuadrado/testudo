<testudo>
  <test name="testudo" title="Testudo" n_failed="79" n_total="310" n_errors="4" success="false">
    <test name="testudo.main" title="main() test" n_failed="0" n_total="0" n_errors="0" success="true">
      <test name="testudo.main.show_tree" title="show test tree" n_failed="0" n_total="0" n_errors="0" success="true">
        <declare>ostringstream trs</declare>
        <perform>testudo::print_tree(trs, testudo::TestNode::root_node())</perform>
        <show_multiline_value>
          <expression1 value="--testudo&#xa;|-main&#xa;|  `-show_tree&#xa;|-use_instructions&#xa;|-testarudo&#xa;|  |-simple&#xa;|  |-complex&#xa;|  |  |-difficult&#xa;|  |  |-complicated&#xa;|  |  |-with_error&#xa;|  |  |-penultimate&#xa;|  |  |-verify_syntax&#xa;|  |  |-try_catch&#xa;|  |  |-test_with_an_absurdly_long_name_so_we_can_check_multiline_cartouches&#xa;|  |  `-with&#xa;|  `-disorder&#xa;|     |-du&#xa;|     |-unu&#xa;|     |-absdiff&#xa;|     |-testarudo_ext&#xa;|     `-no_representation&#xa;|-all_even&#xa;|-fixture&#xa;|  |-addition_commutativity&#xa;|  |-multiplication_commutativity&#xa;|  `-associativity&#xa;|-scope&#xa;|-testudo_syntax&#xa;`-mock_turtle&#xa;   |-queen_of_hearts&#xa;   |-queen_of_hearts_calls&#xa;   |-approx&#xa;   |-several_mocks&#xa;   |-predicates&#xa;   |-exceptions_with_mock&#xa;   `-exceptions_with_wrap&#xa;">trs.str()</expression1>
        </show_multiline_value>
      </test>
    </test>
    <test name="testudo.use_instructions" title="use instructions" n_failed="2" n_total="12" n_errors="1" success="false">
      <multiline_text>index:&#xa;  1. holding functionality&#xa;  2. exceptions&#xa;  3. list of forgotten doubles</multiline_text>
      <separator/>
      <declare>Hold hf</declare>
      <check_true success="true" prefix="">
        <expression1>not hf.is_holding()</expression1>
      </check_true>
      <perform>hf.hold(3.14)</perform>
      <check_true success="true" prefix="">
        <expression1>hf.is_holding()</expression1>
      </check_true>
      <check_approx success="true" prefix="" max_error="eps">
        <expression1 value="3.14">hf.pop()</expression1>
        <expression2 value="3.14">3.14</expression2>
      </check_approx>
      <check_true success="true" prefix="">
        <expression1>not hf.is_holding()</expression1>
      </check_true>
      <separator/>
      <text>hf is empty now</text>
      <step_id id="popping_empty"/>
      <try>hf.pop()</try>
      <catch exception_type="" success="true">not holding any double</catch>
      <perform>hf.hold(2.72)</perform>
      <step_id id="adding_to_already_holding"/>
      <try>hf.hold(7.)</try>
      <catch exception_type="" success="true">already holding a double</catch>
      <separator/>
      <text>the forgotten doubles list is still empty</text>
      <check_true success="false" prefix="">
        <expression1>Hold::is_forgotten_empty()</expression1>
      </check_true>
      <check_equal success="true" prefix="">
        <expression1 value="0">Hold::get_forgotten().size()</expression1>
        <expression2 value="0">0u</expression2>
      </check_equal>
      <scope name="scope 1">
        <declare>Hold hf1(1.1)</declare>
        <declare>Hold hf2(2.2)</declare>
        <scope name="">
          <declare>Hold hf3(3.3)</declare>
        </scope>
        <check_approx success="true" prefix="" max_error=".5">
          <expression1 value="list{3.3}">Hold::get_forgotten()</expression1>
          <expression2 value="list{3}">{3.}</expression2>
        </check_approx>
        <show_value>
          <expression1 value="2.2">hf2.pop()</expression1>
        </show_value>
        <text>hf2 now empty; it won&apos;t add to the list</text>
      </scope>
      <check_true success="true" prefix="">
        <expression1>not Hold::is_forgotten_empty()</expression1>
      </check_true>
      <check_approx success="false" prefix="" max_error="eps">
        <expression1 value="list{1.1, 3.3}">Hold::get_forgotten()</expression1>
        <expression2 value="list{3.3, 1.1}">{3.3, 1.1}</expression2>
      </check_approx>
      <perform>Hold::clear_forgotten()</perform>
      <check_equal success="true" prefix="">
        <expression1 value="0">Hold::get_forgotten().size()</expression1>
        <expression2 value="0">0u</expression2>
      </check_equal>
      <text>the following will raise an error</text>
      <perform>hf.hold(9.9)</perform>
      <uncaught_exception>already holding a double</uncaught_exception>
    </test>
    <test name="testudo.testarudo" title="testarudo tests" n_failed="56" n_total="211" n_errors="2" success="false">
      <test name="testudo.testarudo.simple" title="simple testarudo tests" n_failed="2" n_total="5" n_errors="0" success="false">
        <check_true success="true" prefix="">
          <expression1>true</expression1>
        </check_true>
        <check_true success="false" prefix="">
          <expression1>false</expression1>
        </check_true>
        <check_true success="false" prefix="nay">
          <expression1>true</expression1>
        </check_true>
        <check_true success="true" prefix="nay">
          <expression1>false</expression1>
        </check_true>
        <check_true success="true" prefix="nay">
          <expression1>2+2==5</expression1>
        </check_true>
      </test>
      <test name="testudo.testarudo.complex" title="complex testarudo tests" n_failed="49" n_total="189" n_errors="2" success="false">
        <test name="testudo.testarudo.complex.difficult" title="difficult test" n_failed="1" n_total="3" n_errors="0" success="false">
          <check_equal success="false" prefix="">
            <expression1 value="7">7</expression1>
            <expression2 value="8">8</expression2>
          </check_equal>
          <check_equal success="true" prefix="nay">
            <expression1 value="7">7</expression1>
            <expression2 value="8">8</expression2>
          </check_equal>
          <check_equal success="true" prefix="">
            <expression1 value="un chat">&quot;un chat&quot;</expression1>
            <expression2 value="un chat">string(&quot;un chat&quot;)</expression2>
          </check_equal>
        </test>
        <test name="testudo.testarudo.complex.complicated" title="complicated test" n_failed="2" n_total="2" n_errors="0" success="false">
          <check_equal success="false" prefix="">
            <expression1 value="it&apos;s">&quot;it&apos;s&quot;</expression1>
            <expression2 value="complicated">&quot;complicated&quot;</expression2>
          </check_equal>
          <check_equal success="false" prefix="">
            <expression1 value="54">6*9</expression1>
            <expression2 value="42">42</expression2>
          </check_equal>
        </test>
        <test name="testudo.testarudo.complex.with_error" title="test_with_error" n_failed="0" n_total="1" n_errors="1" success="false">
          <check_equal success="true" prefix="">
            <expression1 value="44">22+22</expression1>
            <expression2 value="44">44</expression2>
          </check_equal>
          <perform>throw runtime_error(&quot;see if you can catch me!&quot;)</perform>
          <uncaught_exception>see if you can catch me!</uncaught_exception>
        </test>
        <test name="testudo.testarudo.complex.penultimate" title="penultimate test" n_failed="1" n_total="1" n_errors="0" success="false">
          <check_equal success="false" prefix="">
            <expression1 value="there&apos;s nothing">&quot;there&apos;s nothing&quot;</expression1>
            <expression2 value="penultimate">&quot;penultimate&quot;</expression2>
          </check_equal>
        </test>
        <test name="testudo.testarudo.complex.verify_syntax" title="&quot;verify&quot; syntax" n_failed="13" n_total="25" n_errors="0" success="false">
          <declare>auto is_even=predicate_a((a%2)==0)</declare>
          <declare>auto is_multiple_of= [](auto n) { return predicate_c_a((n), (a%n)==0); }</declare>
          <check_verify success="true" prefix="">
            <expression1 value="8">2*4</expression1>
            <predicate>is_even</predicate>
          </check_verify>
          <check_verify success="false" prefix="">
            <expression1 value="9">2*4+1</expression1>
            <predicate>is_even</predicate>
          </check_verify>
          <check_verify success="false" prefix="">
            <expression1 value="8">2*4</expression1>
            <predicate>not is_even</predicate>
          </check_verify>
          <check_verify success="true" prefix="">
            <expression1 value="9">2*4+1</expression1>
            <predicate>not is_even</predicate>
          </check_verify>
          <check_verify success="false" prefix="">
            <expression1 value="8">2*4</expression1>
            <predicate>is_even and is_multiple_of(3)</predicate>
          </check_verify>
          <check_verify success="true" prefix="">
            <expression1 value="30">6*5</expression1>
            <predicate>is_even and is_multiple_of(3)</predicate>
          </check_verify>
          <check_verify success="false" prefix="">
            <expression1 value="77">7*11</expression1>
            <predicate>is_even and is_multiple_of(3)</predicate>
          </check_verify>
          <check_verify success="true" prefix="">
            <expression1 value="8">2*4</expression1>
            <predicate>is_even and not is_multiple_of(3)</predicate>
          </check_verify>
          <check_verify success="false" prefix="">
            <expression1 value="30">6*5</expression1>
            <predicate>is_even and not is_multiple_of(3)</predicate>
          </check_verify>
          <check_verify success="false" prefix="">
            <expression1 value="77">7*11</expression1>
            <predicate>is_even and not is_multiple_of(3)</predicate>
          </check_verify>
          <check_verify success="true" prefix="">
            <expression1 value="8">2*4</expression1>
            <predicate>is_even or is_multiple_of(3)</predicate>
          </check_verify>
          <check_verify success="true" prefix="">
            <expression1 value="30">6*5</expression1>
            <predicate>is_even or is_multiple_of(3)</predicate>
          </check_verify>
          <check_verify success="false" prefix="">
            <expression1 value="77">7*11</expression1>
            <predicate>is_even or is_multiple_of(3)</predicate>
          </check_verify>
          <text>the check syntax works with pure lambdas too:</text>
          <declare>auto is_positive=predicate([](int n) { return n&gt;0; })</declare>
          <check_verify success="true" prefix="">
            <expression1 value="8">2*4</expression1>
            <predicate>is_positive</predicate>
          </check_verify>
          <check_verify success="false" prefix="">
            <expression1 value="-8">-2*4</expression1>
            <predicate>is_positive</predicate>
          </check_verify>
          <check_verify success="false" prefix="nay">
            <expression1 value="8">2*4</expression1>
            <predicate>is_even</predicate>
          </check_verify>
          <check_verify success="true" prefix="nay">
            <expression1 value="9">2*4+1</expression1>
            <predicate>is_even</predicate>
          </check_verify>
          <check_verify success="true" prefix="">
            <expression1 value="8">8</expression1>
            <predicate>predicate_a(a&gt;6)</predicate>
          </check_verify>
          <check_verify success="false" prefix="">
            <expression1 value="5">5</expression1>
            <predicate>predicate_a(a&gt;6)</predicate>
          </check_verify>
          <check_verify success="true" prefix="">
            <expression1 value="8">8</expression1>
            <predicate>gt(6)</predicate>
          </check_verify>
          <check_verify success="false" prefix="">
            <expression1 value="5">5</expression1>
            <predicate>gt(6)</predicate>
          </check_verify>
          <check_verify success="true" prefix="">
            <expression1 value="8">8</expression1>
            <predicate>ne(6)</predicate>
          </check_verify>
          <check_verify success="false" prefix="">
            <expression1 value="6">6</expression1>
            <predicate>ne(6)</predicate>
          </check_verify>
          <check_verify success="true" prefix="">
            <expression1 value="8">8</expression1>
            <predicate>gt(6) and lt(10)</predicate>
          </check_verify>
          <check_verify success="false" prefix="">
            <expression1 value="4">4</expression1>
            <predicate>gt(6) and lt(10)</predicate>
          </check_verify>
        </test>
        <test name="testudo.testarudo.complex.try_catch" title="try-catch checks" n_failed="2" n_total="4" n_errors="1" success="false">
          <try>[]() { }()</try>
          <catch exception_type="" success="false">&lt;no exception&gt;</catch>
          <try>throw runtime_error(&quot;this&apos;ll be caught&quot;)</try>
          <catch exception_type="" success="true">this&apos;ll be caught</catch>
          <try>throw &quot;this&apos;ll be too&quot;</try>
          <catch exception_type="char const *" success="true">this&apos;ll be too</catch>
          <try>throw &quot;but this shouldn&apos;t&quot;</try>
          <catch exception_type="" success="false">&lt;unexpected exception&gt;</catch>
          <uncaught_exception>but this shouldn&apos;t</uncaught_exception>
        </test>
        <test name="testudo.testarudo.complex.test_with_an_absurdly_long_name_so_we_can_check_multiline_cartouches" title="a test with so many characters in the name and in the title that it&apos;ll have to be broken across several lines in the cartouche" n_failed="0" n_total="0" n_errors="0" success="true"/>
        <test name="testudo.testarudo.complex.with" title="&quot;with&quot; checks" n_failed="30" n_total="153" n_errors="0" success="false">
          <declare>list&lt;int&gt; numbers_1{2, 4, 8}</declare>
          <declare>list&lt;int&gt; numbers_2{2, 5, 8}</declare>
          <with var="x" container="numbers_1" n_failed="0" n_total="3" n_errors="0" success="true">
            <check_true success="with" prefix="">
              <expression1>(x%2)==0</expression1>
            </check_true>
          </with>
          <with var="x" container="numbers_2" n_failed="1" n_total="3" n_errors="0" success="false">
            <check_true success="with" prefix="">
              <expression1>(x%2)==0</expression1>
            </check_true>
            <with_results>
              <show_value>
                <expression1 value="5">x</expression1>
              </show_value>
              <check_true success="false" prefix="">
                <expression1>(x%2)==0</expression1>
              </check_true>
            </with_results>
          </with>
          <with var="x" container="list&lt;int&gt;{3, 4, 8}" n_failed="1" n_total="3" n_errors="0" success="false">
            <check_true success="with" prefix="">
              <expression1>(x%2)==0</expression1>
            </check_true>
            <with_results>
              <show_value>
                <expression1 value="3">x</expression1>
              </show_value>
              <check_true success="false" prefix="">
                <expression1>(x%2)==0</expression1>
              </check_true>
            </with_results>
          </with>
          <with var="x" container="list&lt;int&gt;{2, 4, 7}" n_failed="1" n_total="3" n_errors="0" success="false">
            <check_true success="with" prefix="">
              <expression1>(x%2)==0</expression1>
            </check_true>
            <with_results>
              <show_value>
                <expression1 value="7">x</expression1>
              </show_value>
              <check_true success="false" prefix="">
                <expression1>(x%2)==0</expression1>
              </check_true>
            </with_results>
          </with>
          <with var="x" container="numbers_1" n_failed="0" n_total="3" n_errors="0" success="true">
            <check_equal success="with" prefix="">
              <expression1 value="">0</expression1>
              <expression2 value="">x%2</expression2>
            </check_equal>
          </with>
          <with var="x" container="numbers_2" n_failed="1" n_total="3" n_errors="0" success="false">
            <check_equal success="with" prefix="">
              <expression1 value="">0</expression1>
              <expression2 value="">x%2</expression2>
            </check_equal>
            <with_results>
              <show_value>
                <expression1 value="5">x</expression1>
              </show_value>
              <check_equal success="false" prefix="">
                <expression1 value="0">0</expression1>
                <expression2 value="1">x%2</expression2>
              </check_equal>
            </with_results>
          </with>
          <separator/>
          <with var="x" container="numbers_1" n_failed="0" n_total="3" n_errors="0" success="true">
            <declare>auto is_even=predicate_a((a%2)==0)</declare>
            <check_verify success="with" prefix="">
              <expression1 value="">x</expression1>
              <predicate>is_even</predicate>
            </check_verify>
            <text>let&apos;s do something, just to see how it&apos;s shown</text>
            <declare>auto y=x+1</declare>
          </with>
          <with var="x" container="numbers_2" n_failed="1" n_total="3" n_errors="0" success="false">
            <declare>auto is_even=predicate_a((a%2)==0)</declare>
            <check_verify success="with" prefix="">
              <expression1 value="">x</expression1>
              <predicate>is_even</predicate>
            </check_verify>
            <with_results>
              <show_value>
                <expression1 value="5">x</expression1>
              </show_value>
              <check_verify success="false" prefix="">
                <expression1 value="5">x</expression1>
                <predicate>is_even</predicate>
              </check_verify>
            </with_results>
            <text>let&apos;s do something, just to see how it&apos;s shown</text>
            <declare>auto y=x+1</declare>
          </with>
          <separator/>
          <with var="x" container="numbers_1" n_failed="3" n_total="9" n_errors="0" success="false">
            <with var="y" container="numbers_2">
              <check_equal success="with" prefix="">
                <expression1 value="">x%2</expression1>
                <expression2 value="">y%2</expression2>
              </check_equal>
              <with_results>
                <show_value>
                  <expression1 value="(2, 5)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="0">x%2</expression1>
                  <expression2 value="1">y%2</expression2>
                </check_equal>
                <show_value>
                  <expression1 value="(4, 5)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="0">x%2</expression1>
                  <expression2 value="1">y%2</expression2>
                </check_equal>
                <show_value>
                  <expression1 value="(8, 5)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="0">x%2</expression1>
                  <expression2 value="1">y%2</expression2>
                </check_equal>
              </with_results>
            </with>
          </with>
          <with var="x" container="list&lt;int&gt;{2, 4, 9}" n_failed="4" n_total="9" n_errors="0" success="false">
            <with var="y" container="numbers_2">
              <check_equal success="with" prefix="">
                <expression1 value="">x%2</expression1>
                <expression2 value="">y%2</expression2>
              </check_equal>
              <with_results>
                <show_value>
                  <expression1 value="(2, 5)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="0">x%2</expression1>
                  <expression2 value="1">y%2</expression2>
                </check_equal>
                <show_value>
                  <expression1 value="(4, 5)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="0">x%2</expression1>
                  <expression2 value="1">y%2</expression2>
                </check_equal>
                <show_value>
                  <expression1 value="(9, 2)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="1">x%2</expression1>
                  <expression2 value="0">y%2</expression2>
                </check_equal>
                <show_value>
                  <expression1 value="(9, 8)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="1">x%2</expression1>
                  <expression2 value="0">y%2</expression2>
                </check_equal>
              </with_results>
            </with>
          </with>
          <with var="x" container="numbers_1" n_failed="0" n_total="9" n_errors="0" success="true">
            <with var="y" container="list&lt;int&gt;{2, 4, 10}">
              <check_equal success="with" prefix="">
                <expression1 value="">x%2</expression1>
                <expression2 value="">y%2</expression2>
              </check_equal>
            </with>
          </with>
          <separator/>
          <declare>auto is_even=predicate_a((a%2)==0)</declare>
          <with var="x" container="numbers_1" n_failed="0" n_total="3" n_errors="0" success="true">
            <check_verify success="with" prefix="">
              <expression1 value="">x</expression1>
              <predicate>is_even</predicate>
            </check_verify>
          </with>
          <with var="x" container="numbers_1" n_failed="0" n_total="3" n_errors="0" success="true">
            <declare>int y=x+1</declare>
            <check_verify success="with" prefix="">
              <expression1 value="">y</expression1>
              <predicate>not is_even</predicate>
            </check_verify>
          </with>
          <with var="x" container="numbers_1" n_failed="0" n_total="12" n_errors="0" success="true">
            <check_verify success="with" prefix="">
              <expression1 value="">x</expression1>
              <predicate>is_even</predicate>
            </check_verify>
            <with var="y" container="numbers_1">
              <check_equal success="with" prefix="">
                <expression1 value="">x%2</expression1>
                <expression2 value="">y%2</expression2>
              </check_equal>
            </with>
          </with>
          <with var="x" container="numbers_1" n_failed="3" n_total="12" n_errors="0" success="false">
            <check_verify success="with" prefix="">
              <expression1 value="">x</expression1>
              <predicate>is_even</predicate>
            </check_verify>
            <with var="y" container="numbers_2">
              <check_equal success="with" prefix="">
                <expression1 value="">x%2</expression1>
                <expression2 value="">y%2</expression2>
              </check_equal>
              <with_results>
                <show_value>
                  <expression1 value="(2, 5)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="0">x%2</expression1>
                  <expression2 value="1">y%2</expression2>
                </check_equal>
                <show_value>
                  <expression1 value="(4, 5)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="0">x%2</expression1>
                  <expression2 value="1">y%2</expression2>
                </check_equal>
                <show_value>
                  <expression1 value="(8, 5)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="0">x%2</expression1>
                  <expression2 value="1">y%2</expression2>
                </check_equal>
              </with_results>
            </with>
          </with>
          <with var="x" container="numbers_2" n_failed="4" n_total="12" n_errors="0" success="false">
            <check_verify success="with" prefix="">
              <expression1 value="">x</expression1>
              <predicate>is_even</predicate>
            </check_verify>
            <with_results>
              <show_value>
                <expression1 value="5">x</expression1>
              </show_value>
              <check_verify success="false" prefix="">
                <expression1 value="5">x</expression1>
                <predicate>is_even</predicate>
              </check_verify>
            </with_results>
            <with var="y" container="numbers_1">
              <check_equal success="with" prefix="">
                <expression1 value="">x%2</expression1>
                <expression2 value="">y%2</expression2>
              </check_equal>
              <with_results>
                <show_value>
                  <expression1 value="(5, 2)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="1">x%2</expression1>
                  <expression2 value="0">y%2</expression2>
                </check_equal>
                <show_value>
                  <expression1 value="(5, 4)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="1">x%2</expression1>
                  <expression2 value="0">y%2</expression2>
                </check_equal>
                <show_value>
                  <expression1 value="(5, 8)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="1">x%2</expression1>
                  <expression2 value="0">y%2</expression2>
                </check_equal>
              </with_results>
            </with>
          </with>
          <with var="x" container="numbers_2" n_failed="5" n_total="12" n_errors="0" success="false">
            <check_verify success="with" prefix="">
              <expression1 value="">x</expression1>
              <predicate>is_even</predicate>
            </check_verify>
            <with_results>
              <show_value>
                <expression1 value="5">x</expression1>
              </show_value>
              <check_verify success="false" prefix="">
                <expression1 value="5">x</expression1>
                <predicate>is_even</predicate>
              </check_verify>
            </with_results>
            <with var="y" container="numbers_2">
              <check_equal success="with" prefix="">
                <expression1 value="">x%2</expression1>
                <expression2 value="">y%2</expression2>
              </check_equal>
              <with_results>
                <show_value>
                  <expression1 value="(2, 5)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="0">x%2</expression1>
                  <expression2 value="1">y%2</expression2>
                </check_equal>
                <show_value>
                  <expression1 value="(5, 2)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="1">x%2</expression1>
                  <expression2 value="0">y%2</expression2>
                </check_equal>
                <show_value>
                  <expression1 value="(5, 8)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="1">x%2</expression1>
                  <expression2 value="0">y%2</expression2>
                </check_equal>
                <show_value>
                  <expression1 value="(8, 5)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="0">x%2</expression1>
                  <expression2 value="1">y%2</expression2>
                </check_equal>
              </with_results>
            </with>
          </with>
          <separator/>
          <with var="x" container="numbers_1" n_failed="6" n_total="45" n_errors="0" success="false">
            <with var="y" container="numbers_1">
              <check_equal success="with" prefix="">
                <expression1 value="">x%2</expression1>
                <expression2 value="">y%2</expression2>
              </check_equal>
            </with>
            <check_verify success="with" prefix="">
              <expression1 value="">x</expression1>
              <predicate>is_even</predicate>
            </check_verify>
            <with var="y" container="numbers_2">
              <check_equal success="with" prefix="">
                <expression1 value="">x%2</expression1>
                <expression2 value="">y%2</expression2>
              </check_equal>
              <with_results>
                <show_value>
                  <expression1 value="(2, 5)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="0">x%2</expression1>
                  <expression2 value="1">y%2</expression2>
                </check_equal>
                <show_value>
                  <expression1 value="(4, 5)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="0">x%2</expression1>
                  <expression2 value="1">y%2</expression2>
                </check_equal>
                <show_value>
                  <expression1 value="(8, 5)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="0">x%2</expression1>
                  <expression2 value="1">y%2</expression2>
                </check_equal>
              </with_results>
            </with>
            <check_verify success="with" prefix="">
              <expression1 value="">x</expression1>
              <predicate>is_even</predicate>
            </check_verify>
            <with var="y" container="numbers_1">
              <check_equal success="with" prefix="">
                <expression1 value="">x%2</expression1>
                <expression2 value="">y%2</expression2>
              </check_equal>
            </with>
            <check_verify success="with" prefix="">
              <expression1 value="">x</expression1>
              <predicate>is_even</predicate>
            </check_verify>
            <with var="y" container="list&lt;int&gt;{2, 4, 9}">
              <check_equal success="with" prefix="">
                <expression1 value="">x%2</expression1>
                <expression2 value="">y%2</expression2>
              </check_equal>
              <with_results>
                <show_value>
                  <expression1 value="(2, 9)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="0">x%2</expression1>
                  <expression2 value="1">y%2</expression2>
                </check_equal>
                <show_value>
                  <expression1 value="(4, 9)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="0">x%2</expression1>
                  <expression2 value="1">y%2</expression2>
                </check_equal>
                <show_value>
                  <expression1 value="(8, 9)">(x, y)</expression1>
                </show_value>
                <check_equal success="false" prefix="">
                  <expression1 value="0">x%2</expression1>
                  <expression2 value="1">y%2</expression2>
                </check_equal>
              </with_results>
            </with>
          </with>
          <with var="x" container="numbers_1" n_failed="0" n_total="3" n_errors="0" success="true">
            <check_verify success="with" prefix="">
              <expression1 value="">0</expression1>
              <predicate>is_even</predicate>
            </check_verify>
          </with>
        </test>
      </test>
      <test name="testudo.testarudo.disorder" title="disordered tests" n_failed="5" n_total="17" n_errors="0" success="false">
        <test name="testudo.testarudo.disorder.du" title="du, but comes first" n_failed="1" n_total="1" n_errors="0" success="false">
          <check_true success="false" prefix="">
            <expression1>string(&quot;unu&quot;)&lt;string(&quot;du&quot;)</expression1>
          </check_true>
        </test>
        <test name="testudo.testarudo.disorder.unu" title="unu, but comes last" n_failed="0" n_total="1" n_errors="0" success="true">
          <check_true success="true" prefix="">
            <expression1>string(&quot;unu&quot;)&gt;string(&quot;du&quot;)</expression1>
          </check_true>
        </test>
        <test name="testudo.testarudo.disorder.absdiff" title="absdiff()" n_failed="0" n_total="4" n_errors="0" success="true">
          <perform>approx_epsilon=1e-10</perform>
          <check_approx success="true" prefix="" max_error="eps">
            <expression1 value="2">testudo::absdiff(5., 7.)</expression1>
            <expression2 value="2">2.</expression2>
          </check_approx>
          <check_approx success="true" prefix="" max_error="eps">
            <expression1 value="2">testudo::absdiff(7., 5.)</expression1>
            <expression2 value="2">2.</expression2>
          </check_approx>
          <check_approx success="true" prefix="" max_error="eps">
            <expression1 value="4">2.+2.</expression1>
            <expression2 value="4">4.</expression2>
          </check_approx>
          <check_approx success="true" prefix="nay" max_error="eps">
            <expression1 value="4">2.+2.</expression1>
            <expression2 value="5">5.</expression2>
          </check_approx>
        </test>
        <test name="testudo.testarudo.disorder.testarudo_ext" title="Testarudo support for STL objects" n_failed="3" n_total="10" n_errors="0" success="false">
          <perform>approx_epsilon=1e-6</perform>
          <declare>tuple&lt;float, int, double&gt; ta={3.14, 8, 7.5}</declare>
          <declare>tuple&lt;double, float, int&gt; tb={4.14, 7., 6}</declare>
          <check_approx success="false" prefix="" max_error="eps">
            <expression1 value="tuple{3.14, 8, 7.5}">ta</expression1>
            <expression2 value="tuple{4.14, 7, 6}">tb</expression2>
          </check_approx>
          <show_value>
            <expression1 value="3.5">absdiff(ta, tb)</expression1>
          </show_value>
          <declare>tuple&lt;float, int, double&gt; tc={3.14, 8, 7.5}</declare>
          <check_approx success="true" prefix="" max_error="eps">
            <expression1 value="tuple{3.14, 8, 7.5}">ta</expression1>
            <expression2 value="tuple{3.14, 8, 7.5}">tc</expression2>
          </check_approx>
          <separator/>
          <declare>list&lt;float&gt; la={3.14, 8, 7.5}</declare>
          <declare>list&lt;float&gt; lb={4.14, 7., 6}</declare>
          <check_approx success="false" prefix="" max_error="eps">
            <expression1 value="list{3.14, 8, 7.5}">la</expression1>
            <expression2 value="list{4.14, 7, 6}">lb</expression2>
          </check_approx>
          <show_value>
            <expression1 value="3.5">absdiff(la, lb)</expression1>
          </show_value>
          <declare>list&lt;float&gt; lc={3.14, 8, 7.5}</declare>
          <check_approx success="true" prefix="" max_error="eps">
            <expression1 value="list{3.14, 8, 7.5}">la</expression1>
            <expression2 value="list{3.14, 8, 7.5}">lc</expression2>
          </check_approx>
          <declare_scope declare="auto x=string(&quot;hey&quot;)">
            <check_equal success="true" prefix="">
              <expression1 value="hey">x</expression1>
              <expression2 value="hey">&quot;hey&quot;</expression2>
            </check_equal>
            <check_equal success="true" prefix="nay">
              <expression1 value="hey">x</expression1>
              <expression2 value="hi">&quot;hi&quot;</expression2>
            </check_equal>
          </declare_scope>
          <declare_scope declare="auto x=-12">
            <check_equal success="false" prefix="">
              <expression1 value="-12">x</expression1>
              <expression2 value="77">77</expression2>
            </check_equal>
            <check_equal success="true" prefix="nay">
              <expression1 value="-12">x</expression1>
              <expression2 value="3">3</expression2>
            </check_equal>
          </declare_scope>
          <declare_scope declare="auto [action, occurrences]=tuple{&quot;sin&quot;, 77*7}">
            <check_equal success="true" prefix="">
              <expression1 value="sin">action</expression1>
              <expression2 value="sin">&quot;sin&quot;</expression2>
            </check_equal>
            <check_equal success="true" prefix="">
              <expression1 value="539">occurrences</expression1>
              <expression2 value="539">539</expression2>
            </check_equal>
          </declare_scope>
        </test>
        <test name="testudo.testarudo.disorder.no_representation" title="class with no representation" n_failed="1" n_total="1" n_errors="0" success="false">
          <check_equal success="false" prefix="">
            <expression1 value="&lt;...&gt;">ClassWithNoRepresentation()</expression1>
            <expression2 value="&lt;...&gt;">ClassWithNoRepresentation()</expression2>
          </check_equal>
        </test>
      </test>
    </test>
    <test name="testudo.all_even" title="all_even" n_failed="1" n_total="4" n_errors="0" success="false">
      <show_value>
        <expression1 value="1">datum_number</expression1>
      </show_value>
      <show_value>
        <expression1 value="2">datum</expression1>
      </show_value>
      <check_equal success="true" prefix="">
        <expression1 value="0">datum%2</expression1>
        <expression2 value="0">0</expression2>
      </check_equal>
      <separator/>
      <show_value>
        <expression1 value="2">datum_number</expression1>
      </show_value>
      <show_value>
        <expression1 value="4">datum</expression1>
      </show_value>
      <check_equal success="true" prefix="">
        <expression1 value="0">datum%2</expression1>
        <expression2 value="0">0</expression2>
      </check_equal>
      <separator/>
      <show_value>
        <expression1 value="3">datum_number</expression1>
      </show_value>
      <show_value>
        <expression1 value="5">datum</expression1>
      </show_value>
      <check_equal success="false" prefix="">
        <expression1 value="1">datum%2</expression1>
        <expression2 value="0">0</expression2>
      </check_equal>
      <separator/>
      <show_value>
        <expression1 value="4">datum_number</expression1>
      </show_value>
      <show_value>
        <expression1 value="6">datum</expression1>
      </show_value>
      <check_equal success="true" prefix="">
        <expression1 value="0">datum%2</expression1>
        <expression2 value="0">0</expression2>
      </check_equal>
      <separator/>
    </test>
    <test name="testudo.fixture" title="fixture tests" n_failed="0" n_total="9" n_errors="1" success="false">
      <test name="testudo.fixture.addition_commutativity" title="+ commutativity" n_failed="0" n_total="4" n_errors="0" success="true">
        <text>visible fixture NumbersFixture</text>
        <declare>(fixture) double x</declare>
        <perform>(fixture) init x(1.)</perform>
        <declare>(fixture) double y=-2.5, z</declare>
        <perform>(fixture) init z(3.14)</perform>
        <text>fixture constructor done</text>
        <perform>check_initial_values()</perform>
        <check_approx success="true" prefix="" max_error="eps">
          <expression1 value="1">x</expression1>
          <expression2 value="1">1.</expression2>
        </check_approx>
        <check_approx success="true" prefix="" max_error="eps">
          <expression1 value="-2.5">y</expression1>
          <expression2 value="-2.5">-2.5</expression2>
        </check_approx>
        <check_approx success="true" prefix="" max_error="eps">
          <expression1 value="3.14">z</expression1>
          <expression2 value="3.14">3.14</expression2>
        </check_approx>
        <check_approx success="true" prefix="" max_error="eps">
          <expression1 value="-1.5">x+y</expression1>
          <expression2 value="-1.5">y+x</expression2>
        </check_approx>
        <text>fixture destructor</text>
      </test>
      <test name="testudo.fixture.multiplication_commutativity" title="* commutativity" n_failed="0" n_total="4" n_errors="0" success="true">
        <text>with fixture NumbersFixture</text>
        <perform>check_initial_values()</perform>
        <check_approx success="true" prefix="" max_error="eps">
          <expression1 value="-2.5">x*y</expression1>
          <expression2 value="-2.5">y*x</expression2>
        </check_approx>
      </test>
      <test name="testudo.fixture.associativity" title="associativity" n_failed="0" n_total="1" n_errors="1" success="false">
        <text>with fixture NumbersFixture</text>
        <check_approx success="true" prefix="" max_error="eps">
          <expression1 value="0.64">x*(y+z)</expression1>
          <expression2 value="0.64">x*y+x*z</expression2>
        </check_approx>
        <perform>throw_something_unexpected()</perform>
        <uncaught_exception>hey, here&apos;s something unexpected</uncaught_exception>
      </test>
    </test>
    <test name="testudo.scope" title="scope begin and end" n_failed="1" n_total="5" n_errors="0" success="false">
      <declare>int flag=10</declare>
      <scope name="at_destruction_flag_20">
        <declare>AtDestruction at_destruction_flag_20([&amp;flag]() { flag=20; })</declare>
        <scope name="">
          <declare>AtDestruction at_destruction_flag_30([&amp;flag]() { flag=30; })</declare>
          <check_equal success="true" prefix="">
            <expression1 value="10">flag</expression1>
            <expression2 value="10">10</expression2>
          </check_equal>
          <text>now, a long text to check line breaking within scopes (the following two tests have the same purpose)</text>
          <check_equal success="true" prefix="">
            <expression1 value="1 2 3 4 5 6 7 8 9">string(&quot;1 2 3 4 5 6 7 8 9&quot;)</expression1>
            <expression2 value="1 2 3 4 5 6 7 8 9">&quot;1 2 3 4 5 6 7 8 9&quot;</expression2>
          </check_equal>
          <check_equal success="false" prefix="">
            <expression1 value="1 2 3 4 5 6 7 8 9">string(&quot;1 2 3 4 5 6 7 8 9&quot;)</expression1>
            <expression2 value="1 2 3 4 5 6 7 8 8">&quot;1 2 3 4 5 6 7 8 8&quot;</expression2>
          </check_equal>
        </scope>
        <check_equal success="true" prefix="">
          <expression1 value="30">flag</expression1>
          <expression2 value="30">30</expression2>
        </check_equal>
      </scope>
      <check_equal success="true" prefix="">
        <expression1 value="20">flag</expression1>
        <expression2 value="20">20</expression2>
      </check_equal>
    </test>
    <test name="testudo.testudo_syntax" title="Testudo syntax" n_failed="0" n_total="1" n_errors="0" success="true">
      <text>tags in &quot;||||~tilde~||~&quot;...&quot;||~tilde~||~||&quot; are used internally</text>
      <text>but they should still appear here</text>
      <declare>string code=&quot;||~tilde~||~pre||~tilde~||~ ||||~tilde~||~bold||~tilde~||~|| ||~tilde~||~post||~tilde~||~&quot;</declare>
      <show_value>
        <expression1 value="||~tilde~||~pre||~tilde~||~ ||||~tilde~||~bold||~tilde~||~|| ||~tilde~||~post||~tilde~||~">code</expression1>
      </show_value>
      <check_equal success="true" prefix="">
        <expression1 value="||~tilde~||~pre||~tilde~||~ ||||~tilde~||~bold||~tilde~||~|| ||~tilde~||~post||~tilde~||~">code</expression1>
        <expression2 value="||~tilde~||~pre||~tilde~||~ ||||~tilde~||~bold||~tilde~||~|| ||~tilde~||~post||~tilde~||~">&quot;||~tilde~||~pre||~tilde~||~ ||||~tilde~||~bold||~tilde~||~|| ||~tilde~||~post||~tilde~||~&quot;</expression2>
      </check_equal>
    </test>
    <test name="testudo.mock_turtle" title="mock turtle tests" n_failed="19" n_total="68" n_errors="0" success="false">
      <test name="testudo.mock_turtle.queen_of_hearts" title="Queen of Hearts&apos; recipe" n_failed="0" n_total="9" n_errors="0" success="true">
        <declare>auto soup_mock=make_shared&lt;SoupMock&gt;()</declare>
        <check_equal success="true" prefix="">
          <expression1 value="pair{2, 1}">soup_mock-&gt;reverse({1, 2})</expression1>
          <expression2 value="pair{2, 1}">pair(2, 1)</expression2>
        </check_equal>
        <perform>soup_mock-&gt;schedule_ret(temp, 20, 40, 60, 80, 100)</perform>
        <declare>bool good=queen_of_hearts_mock_turtle_soup(soup_mock)</declare>
        <check_true success="true" prefix="">
          <expression1>good</expression1>
        </check_true>
        <check_equal success="true" prefix="">
          <expression1 value="vector{tuple{calf brains, 4}, tuple{pork liver, 3}, tuple{water, 1}, tuple{water, 1}, tuple{water, 1}}">soup_mock-&gt;logged_args(add_ingr)</expression1>
          <expression2 value="vector{tuple{calf brains, 4}, tuple{pork liver, 3}, tuple{water, 1}, tuple{water, 1}, tuple{water, 1}}">{{&quot;calf brains&quot;, 4}, {&quot;pork liver&quot;, 3}, {&quot;water&quot;, 1}, {&quot;water&quot;, 1}, {&quot;water&quot;, 1}}</expression2>
        </check_equal>
        <check_equal success="true" prefix="">
          <expression1 value="vector{pair{tuple{4}, tuple{calf brains, 4}}, pair{tuple{7}, tuple{pork liver, 3}}, pair{tuple{8}, tuple{water, 1}}, pair{tuple{9}, tuple{water, 1}}, pair{tuple{10}, tuple{water, 1}}}">soup_mock-&gt;logged_ret_args(add_ingr)</expression1>
          <expression2 value="vector{pair{tuple{4}, tuple{calf brains, 4}}, pair{tuple{7}, tuple{pork liver, 3}}, pair{tuple{8}, tuple{water, 1}}, pair{tuple{9}, tuple{water, 1}}, pair{tuple{10}, tuple{water, 1}}}">{{{4}, {&quot;calf brains&quot;, 4}}, {{7}, {&quot;pork liver&quot;, 3}}, {{8}, {&quot;water&quot;, 1}}, {{9}, {&quot;water&quot;, 1}}, {{10}, {&quot;water&quot;, 1}}}</expression2>
        </check_equal>
        <check_equal success="true" prefix="">
          <expression1 value="vector{tuple{9}, tuple{5}}">soup_mock-&gt;logged_args(set_heat)</expression1>
          <expression2 value="vector{tuple{9}, tuple{5}}">{{9}, {5}}</expression2>
        </check_equal>
        <check_equal success="true" prefix="">
          <expression1 value="14">soup_mock-&gt;log_size(wait)</expression1>
          <expression2 value="14">14</expression2>
        </check_equal>
        <check_equal success="true" prefix="">
          <expression1 value="map{{calf brains, 4}, {pork liver, 3}, {water, 3}}">soup_mock-&gt;content</expression1>
          <expression2 value="map{{calf brains, 4}, {pork liver, 3}, {water, 3}}">{{&quot;calf brains&quot;, 4}, {&quot;pork liver&quot;, 3}, {&quot;water&quot;, 3}}</expression2>
        </check_equal>
        <check_equal success="true" prefix="">
          <expression1 value="1">soup_mock-&gt;log_size(is_tasty)</expression1>
          <expression2 value="1">1</expression2>
        </check_equal>
        <check_equal success="true" prefix="">
          <expression1 value="vector{tuple{true}}">soup_mock-&gt;logged_ret(is_tasty)</expression1>
          <expression2 value="vector{tuple{true}}">{{true}}</expression2>
        </check_equal>
      </test>
      <test name="testudo.mock_turtle.queen_of_hearts_calls" title="Queen of Hearts&apos; recipe calls" n_failed="5" n_total="17" n_errors="0" success="false">
        <declare>auto soup_mock=make_shared&lt;SoupMock&gt;()</declare>
        <perform>soup_mock-&gt;set_ret_default(forty_two, 6*9)</perform>
        <check_equal success="true" prefix="">
          <expression1 value="pair{2, 1}">soup_mock-&gt;reverse({1, 2})</expression1>
          <expression2 value="pair{2, 1}">pair(2, 1)</expression2>
        </check_equal>
        <check_equal success="true" prefix="">
          <expression1 value="54">soup_mock-&gt;forty_two()</expression1>
          <expression2 value="54">54</expression2>
        </check_equal>
        <check_equal success="true" prefix="">
          <expression1 value="0">soup_mock-&gt;counter</expression1>
          <expression2 value="0">0</expression2>
        </check_equal>
        <perform>soup_mock-&gt;inc_counter()</perform>
        <check_equal success="true" prefix="">
          <expression1 value="1">soup_mock-&gt;counter</expression1>
          <expression2 value="1">1</expression2>
        </check_equal>
        <perform>soup_mock-&gt;add_counter(3)</perform>
        <check_equal success="true" prefix="">
          <expression1 value="4">soup_mock-&gt;counter</expression1>
          <expression2 value="4">4</expression2>
        </check_equal>
        <perform>soup_mock-&gt;schedule_ret(temp, 20, 40, 60, 80, 100)</perform>
        <perform>queen_of_hearts_mock_turtle_soup(soup_mock)</perform>
        <show_multiline_value>
          <expression1 value="{reverse @ 0}&#xa;{forty_two @ 0}&#xa;{inc_counter @ 0}&#xa;{add_counter @ 0}&#xa;{add_ingr @ 0} -- {add_ingr @ 4}&#xa;{set_heat @ 0}&#xa;{temp @ 0}&#xa;{wait @ 0}&#xa;{temp @ 1}&#xa;{wait @ 1}&#xa;{temp @ 2}&#xa;{wait @ 2}&#xa;{temp @ 3}&#xa;{wait @ 3}&#xa;{temp @ 4}&#xa;{set_heat @ 1}&#xa;{wait @ 4} -- {wait @ 13}&#xa;{is_tasty @ 0}&#xa;">print_calls(soup_mock-&gt;calls())</expression1>
        </show_multiline_value>
        <declare_scope declare="auto it=iterate(soup_mock)">
          <declare_scope declare="auto call=it.pop_call(*soup_mock, reverse)">
            <check_equal success="true" prefix="">
              <expression1 value="reverse:{pair{2, 1} (pair{1, 2})}">call</expression1>
              <expression2 value="{pair{2, 1} (pair{1, 2})}">{{2, 1}}, {{1, 2}}</expression2>
            </check_equal>
            <check_equal success="false" prefix="">
              <expression1 value="reverse:{pair{2, 1} (pair{1, 2})}">call</expression1>
              <expression2 value="{pair{3, 1} (pair{1, 2})}">{{3, 1}}, {{1, 2}}</expression2>
            </check_equal>
            <check_equal success="false" prefix="nay">
              <expression1 value="reverse:{pair{2, 1} (pair{1, 2})}">call</expression1>
              <expression2 value="{pair{2, 1} (pair{1, 2})}">{{2, 1}}, {{1, 2}}</expression2>
            </check_equal>
            <check_equal success="true" prefix="nay">
              <expression1 value="reverse:{pair{2, 1} (pair{1, 2})}">call</expression1>
              <expression2 value="{pair{3, 1} (pair{1, 2})}">{{3, 1}}, {{1, 2}}</expression2>
            </check_equal>
          </declare_scope>
          <check_equal success="true" prefix="">
            <expression1 value="forty_two:{54 ()}">it.pop_call(*soup_mock, forty_two)</expression1>
            <expression2 value="{54 ()}">{54}, {}</expression2>
          </check_equal>
          <declare_scope declare="auto call=it.get_call(*soup_mock, inc_counter)">
            <check_equal success="true" prefix="">
              <expression1 value="inc_counter:{void ()}">call</expression1>
              <expression2 value="{void ()}">{}, {}</expression2>
            </check_equal>
          </declare_scope>
          <perform>it.next()</perform>
          <check_equal success="true" prefix="">
            <expression1 value="add_counter:{void (3)}">it.pop_call(*soup_mock, add_counter)</expression1>
            <expression2 value="{void (3)}">{}, {3}</expression2>
          </check_equal>
          <perform>while (it.method_name() not_eq &quot;set_heat&quot;) it.next()</perform>
          <declare_scope declare="auto call=it.pop_call(*soup_mock, reverse)">
            <check_equal success="false" prefix="">
              <expression1 value="reverse:invalid">call</expression1>
              <expression2 value="{pair{2, 1} (pair{1, 2})}">{{2, 1}}, {{1, 2}}</expression2>
            </check_equal>
            <check_equal success="false" prefix="nay">
              <expression1 value="reverse:invalid">call</expression1>
              <expression2 value="{pair{2, 1} (pair{1, 2})}">{{2, 1}}, {{1, 2}}</expression2>
            </check_equal>
          </declare_scope>
          <declare_scope declare="auto call=it.pop_call(*soup_mock, set_heat)">
            <check_equal success="true" prefix="">
              <expression1 value="set_heat:{void (9)}">call</expression1>
              <expression2 value="{void (9)}">{}, {9}</expression2>
            </check_equal>
            <check_equal success="false" prefix="">
              <expression1 value="set_heat:{void (9)}">call</expression1>
              <expression2 value="{void (0)}">{}, {0}</expression2>
            </check_equal>
          </declare_scope>
          <perform>while (it) show_value(it.method_name()), it.next()</perform>
          <show_value>
            <expression1 value="temp">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="wait">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="temp">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="wait">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="temp">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="wait">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="temp">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="wait">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="temp">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="set_heat">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="wait">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="wait">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="wait">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="wait">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="wait">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="wait">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="wait">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="wait">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="wait">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="wait">it.method_name()</expression1>
          </show_value>
          <show_value>
            <expression1 value="is_tasty">it.method_name()</expression1>
          </show_value>
          <check_true success="true" prefix="">
            <expression1>it.done()</expression1>
          </check_true>
        </declare_scope>
      </test>
      <test name="testudo.mock_turtle.approx" title="approx" n_failed="6" n_total="9" n_errors="0" success="false">
        <declare>auto soup_mock=make_shared&lt;SoupMock&gt;()</declare>
        <check_equal success="true" prefix="">
          <expression1 value="pair{2, 1}">soup_mock-&gt;reverse_float({1., 2.})</expression1>
          <expression2 value="pair{2, 1}">pair(2., 1.)</expression2>
        </check_equal>
        <declare_scope declare="auto it=iterate(soup_mock)">
          <text>wrong method:</text>
          <declare_scope declare="auto call=it.pop_call(*soup_mock, reverse)">
            <check_approx success="false" prefix="" max_error="eps">
              <expression1 value="reverse:invalid">call</expression1>
              <expression2 value="{pair{2, 1} (pair{1, 2})}">{{2., 1.}}, {{1., 2.}}</expression2>
            </check_approx>
            <check_approx success="false" prefix="" max_error="eps">
              <expression1 value="reverse:invalid">call</expression1>
              <expression2 value="{pair{3, 1} (pair{1, 2})}">{{3., 1.}}, {{1., 2.}}</expression2>
            </check_approx>
            <check_approx success="false" prefix="nay" max_error="eps">
              <expression1 value="reverse:invalid">call</expression1>
              <expression2 value="{pair{2, 1} (pair{1, 2})}">{{2., 1.}}, {{1., 2.}}</expression2>
            </check_approx>
            <check_approx success="false" prefix="nay" max_error="eps">
              <expression1 value="reverse:invalid">call</expression1>
              <expression2 value="{pair{3, 1} (pair{1, 2})}">{{3., 1.}}, {{1., 2.}}</expression2>
            </check_approx>
          </declare_scope>
          <text>right method:</text>
          <declare_scope declare="auto call=it.pop_call(*soup_mock, reverse_float)">
            <check_approx success="true" prefix="" max_error="eps">
              <expression1 value="reverse_float:{pair{2, 1} (pair{1, 2})}">call</expression1>
              <expression2 value="{pair{2, 1} (pair{1, 2})}">{{2., 1.}}, {{1., 2.}}</expression2>
            </check_approx>
            <check_approx success="false" prefix="" max_error="eps">
              <expression1 value="reverse_float:{pair{2, 1} (pair{1, 2})}">call</expression1>
              <expression2 value="{pair{3, 1} (pair{1, 2})}">{{3., 1.}}, {{1., 2.}}</expression2>
            </check_approx>
            <check_approx success="false" prefix="nay" max_error="eps">
              <expression1 value="reverse_float:{pair{2, 1} (pair{1, 2})}">call</expression1>
              <expression2 value="{pair{2, 1} (pair{1, 2})}">{{2., 1.}}, {{1., 2.}}</expression2>
            </check_approx>
            <check_approx success="true" prefix="nay" max_error="eps">
              <expression1 value="reverse_float:{pair{2, 1} (pair{1, 2})}">call</expression1>
              <expression2 value="{pair{3, 1} (pair{1, 2})}">{{3., 1.}}, {{1., 2.}}</expression2>
            </check_approx>
          </declare_scope>
        </declare_scope>
      </test>
      <test name="testudo.mock_turtle.several_mocks" title="calls with several mocks" n_failed="1" n_total="8" n_errors="0" success="false">
        <declare>CallLedger cl</declare>
        <declare>MockLevel lev1(12)</declare>
        <perform>call_ledger_report_to(lev1, &amp;cl)</perform>
        <declare>MockLevel lev2(47)</declare>
        <perform>call_ledger_report_to(lev2, &amp;cl)</perform>
        <perform>equalize(lev1, lev2)</perform>
        <check_equal success="true" prefix="">
          <expression1 value="52">lev1.readout()</expression1>
          <expression2 value="52">52</expression2>
        </check_equal>
        <check_equal success="true" prefix="">
          <expression1 value="52">lev2.readout()</expression1>
          <expression2 value="52">52</expression2>
        </check_equal>
        <show_multiline_value>
          <expression1 value="{lev1.readout @ 0}&#xa;{lev2.readout @ 0}&#xa;{lev1.readout @ 1}&#xa;{lev2.readout @ 1}&#xa;{lev1.large_up @ 0}&#xa;{lev1.readout @ 2}&#xa;{lev2.readout @ 2}&#xa;{lev1.large_up @ 1}&#xa;{lev1.readout @ 3}&#xa;{lev2.readout @ 3}&#xa;{lev1.large_up @ 2}&#xa;{lev1.readout @ 4}&#xa;{lev2.readout @ 4}&#xa;{lev1.large_up @ 3}&#xa;{lev1.readout @ 5}&#xa;{lev2.readout @ 5} -- {lev2.readout @ 6}&#xa;{lev1.readout @ 6}&#xa;{lev2.small_up @ 0}&#xa;{lev2.readout @ 7}&#xa;{lev1.readout @ 7}&#xa;{lev2.small_up @ 1}&#xa;{lev2.readout @ 8}&#xa;{lev1.readout @ 8}&#xa;{lev2.small_up @ 2}&#xa;{lev2.readout @ 9}&#xa;{lev1.readout @ 9}&#xa;{lev2.small_up @ 3}&#xa;{lev2.readout @ 10}&#xa;{lev1.readout @ 10}&#xa;{lev2.small_up @ 4}&#xa;{lev2.readout @ 11}&#xa;{lev1.readout @ 11} -- {lev1.readout @ 12}&#xa;{lev2.readout @ 12}&#xa;">print_calls(cl.calls())</expression1>
        </show_multiline_value>
        <declare>auto it=iterate(cl)</declare>
        <perform>while (it.method_name() not_eq &quot;large_up&quot;) it.next()</perform>
        <check_equal success="true" prefix="">
          <expression1 value="lev1">it.mock_name()</expression1>
          <expression2 value="lev1">&quot;lev1&quot;</expression2>
        </check_equal>
        <check_equal success="true" prefix="">
          <expression1 value="large_up">it.method_name()</expression1>
          <expression2 value="large_up">&quot;large_up&quot;</expression2>
        </check_equal>
        <check_equal success="true" prefix="">
          <expression1 value="large_up:{void ()}">it.get_call(lev1, large_up)</expression1>
          <expression2 value="{void ()}">{}, {}</expression2>
        </check_equal>
        <check_equal success="false" prefix="">
          <expression1 value="large_up:invalid">it.get_call(lev2, large_up)</expression1>
          <expression2 value="{void ()}">{}, {}</expression2>
        </check_equal>
        <perform>it.next()</perform>
        <check_equal success="true" prefix="">
          <expression1 value="lev1">it.mock_name()</expression1>
          <expression2 value="lev1">&quot;lev1&quot;</expression2>
        </check_equal>
        <check_equal success="true" prefix="">
          <expression1 value="readout">it.method_name()</expression1>
          <expression2 value="readout">&quot;readout&quot;</expression2>
        </check_equal>
      </test>
      <test name="testudo.mock_turtle.predicates" title="predicates" n_failed="7" n_total="13" n_errors="0" success="false">
        <check_verify success="true" prefix="">
          <expression1 value="list{tuple{1, one}, tuple{1, one}}">list&lt;tuple&lt;int, string&gt;&gt;{{1, &quot;one&quot;}, {1, &quot;one&quot;}}</expression1>
          <predicate>is_always(1, &quot;one&quot;)</predicate>
        </check_verify>
        <check_verify success="false" prefix="">
          <expression1 value="list{tuple{1, one}, tuple{2, one}}">list&lt;tuple&lt;int, string&gt;&gt;{{1, &quot;one&quot;}, {2, &quot;one&quot;}}</expression1>
          <predicate>is_always(1, &quot;one&quot;)</predicate>
        </check_verify>
        <check_verify success="true" prefix="">
          <expression1 value="list{2, 2, 2}">list{2, 2, 2}</expression1>
          <predicate>is_always(2)</predicate>
        </check_verify>
        <check_verify success="true" prefix="">
          <expression1 value="list{tuple{2}, tuple{2}, tuple{2}}">list&lt;tuple&lt;int&gt;&gt;{{2}, {2}, {2}}</expression1>
          <predicate>is_always(2)</predicate>
        </check_verify>
        <check_verify success="false" prefix="">
          <expression1 value="list{2, 3, 2}">list{2, 3, 2}</expression1>
          <predicate>is_always(2)</predicate>
        </check_verify>
        <check_verify success="false" prefix="">
          <expression1 value="list{tuple{2}, tuple{3}, tuple{2}}">list&lt;tuple&lt;int&gt;&gt;{{2}, {3}, {2}}</expression1>
          <predicate>is_always(2)</predicate>
        </check_verify>
        <check_verify success="true" prefix="">
          <expression1 value="list{1, 2, 3}">list{1, 2, 3}</expression1>
          <predicate>is_never(4)</predicate>
        </check_verify>
        <check_verify success="false" prefix="">
          <expression1 value="list{1, 2, 3}">list{1, 2, 3}</expression1>
          <predicate>is_never(1)</predicate>
        </check_verify>
        <check_verify success="false" prefix="">
          <expression1 value="list{1, 1, 4}">list{1, 1, 4}</expression1>
          <predicate>is_constant</predicate>
        </check_verify>
        <check_verify success="true" prefix="">
          <expression1 value="list{1, 1, 1}">list{1, 1, 1}</expression1>
          <predicate>is_constant</predicate>
        </check_verify>
        <check_verify success="true" prefix="">
          <expression1 value="list{1, 2, 3}">list{1, 2, 3}</expression1>
          <predicate>all_different</predicate>
        </check_verify>
        <check_verify success="false" prefix="">
          <expression1 value="list{1, 2, 1}">list{1, 2, 1}</expression1>
          <predicate>all_different</predicate>
        </check_verify>
        <check_verify success="false" prefix="">
          <expression1 value="list{1, 2, 2}">list{1, 2, 2}</expression1>
          <predicate>all_different</predicate>
        </check_verify>
      </test>
      <test name="testudo.mock_turtle.exceptions_with_mock" title="exceptions with mock" n_failed="0" n_total="6" n_errors="0" success="true">
        <declare>MockNamable namable</declare>
        <perform>namable.schedule_ret(set_name_is_good, true, throw_exception(runtime_error(&quot;already named&quot;)))</perform>
        <perform>namable.schedule_ret(create, void_v, throw_exception(runtime_error(&quot;already created&quot;)))</perform>
        <perform>namable.create()</perform>
        <perform>namable.set_name_is_good(&quot;Prince&quot;)</perform>
        <try>namable.set_name_is_good(&quot;the Artist&quot;)</try>
        <catch exception_type="" success="true">already named</catch>
        <try>namable.create()</try>
        <catch exception_type="" success="true">already created</catch>
        <check_equal success="true" prefix="">
          <expression1 value="2">namable.log_size(set_name_is_good)</expression1>
          <expression2 value="2">2</expression2>
        </check_equal>
        <check_equal success="true" prefix="">
          <expression1 value="vector{tuple{Prince}, tuple{the Artist}}">namable.logged_args(set_name_is_good)</expression1>
          <expression2 value="vector{tuple{Prince}, tuple{the Artist}}">{{&quot;Prince&quot;}, {&quot;the Artist&quot;}}</expression2>
        </check_equal>
        <check_equal success="true" prefix="">
          <expression1 value="tuple{true}">namable.logged_ret(set_name_is_good)[0]</expression1>
          <expression2 value="tuple{true}">{true}</expression2>
        </check_equal>
        <check_equal success="true" prefix="">
          <expression1 value="2">namable.log_size(create)</expression1>
          <expression2 value="2">2</expression2>
        </check_equal>
      </test>
      <test name="testudo.mock_turtle.exceptions_with_wrap" title="exceptions with wrap" n_failed="0" n_total="6" n_errors="0" success="true">
        <declare>WrapNamable namable</declare>
        <perform>namable.create()</perform>
        <perform>namable.set_name_is_good(&quot;Prince&quot;)</perform>
        <try>namable.set_name_is_good(&quot;the Artist&quot;)</try>
        <catch exception_type="" success="true">already named</catch>
        <try>namable.create()</try>
        <catch exception_type="" success="true">already created</catch>
        <check_equal success="true" prefix="">
          <expression1 value="2">namable.log_size(set_name_is_good)</expression1>
          <expression2 value="2">2</expression2>
        </check_equal>
        <check_equal success="true" prefix="">
          <expression1 value="vector{tuple{Prince}, tuple{the Artist}}">namable.logged_args(set_name_is_good)</expression1>
          <expression2 value="vector{tuple{Prince}, tuple{the Artist}}">{{&quot;Prince&quot;}, {&quot;the Artist&quot;}}</expression2>
        </check_equal>
        <check_equal success="true" prefix="">
          <expression1 value="tuple{true}">namable.logged_ret(set_name_is_good)[0]</expression1>
          <expression2 value="tuple{true}">{true}</expression2>
        </check_equal>
        <check_equal success="true" prefix="">
          <expression1 value="2">namable.log_size(create)</expression1>
          <expression2 value="2">2</expression2>
        </check_equal>
      </test>
    </test>
  </test>
</testudo>
